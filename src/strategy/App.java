package strategy;

public class App {
    public static void main(String[] args) {
        CoffeeMachine m = new CoffeeMachine();
        m.brew(new Americano());

        // 아직 전략 패턴이 아님

        // 커피머신의 책임 : 커피를 만드는 것, 아매리카노 : 그냥 객체, 앱 : 여기서 실행
        // 전략 패턴을 적용하는 이유 : 여기서 카페라떼 객체가 추가 된다면,
        // 우선 커피머신 - brew에 아메리카노만 쓰고 있음
        // 객체를 쓰고 있을 때, 앱에서 다른 객체를 사용하려면 커피 머신도 수정해야 됨 => 오버로딩 구현
        m.brew(new CafeLatte());

        // 이것도 아직 문제 : 객체가 많아지면 커피 머신에 메서드를 계속 추가해야 됨 => ocp 개방폐쇄 원칙 위배(본코드를 수정하지 않고 확장성 있게 만들어야 됨)
        // 새로운 코드는 만드는 것은 오픈, 기존 코드를 수정하는 건 폐쇄

        // 수정2 : 커피 인터페이스를 생성해서, 각 객체에 implement하면, 커피(부모 인터페이스)에 있는 make를 오버라이딩하게 됨
        // 이렇게 구체적인 게 아닌 추상적인 것에 의존하면, 본코드를 수정할 필요가 없음
        // ocp를 지킬 수 있으며 dip를 사용할 수 있음
        // dip (의존관계 역전 원칙) : 추상적인 것에 의존함으로서 의존 관계를 반전시킴(구체 -> 추상으로)
        // 전략패턴을 통해 solid 객체지향원칙 지킬 수 있음
    }
}
